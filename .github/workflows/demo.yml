name: Deploy website
on:
  push:
    branches:
      - main
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies # we must add step before where files are produced
        uses: actions/cache@v4
        with:
          path: ~/.npm #it's this path that should be cached, npm already builds a cache that contains the dependencies that were installed
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }} #this key will be used to retrieve the cache and recreating that folder on the runner machine, but also if the cache should be discarded because it must be recreated after some dependencies changes
          #hash simply produces a unique hash value based on a file path we pass to it and that hash value will change whenever the file we pass to it changes
          #basically this line says, with the action, this npm created cache folder should be stored in some place in GitHub cloud server and should be reused in other jobs and other workflow executions
          #this cache step does not execute just here but also after the overall job finished to update the cache, so that if dependencies were installed aka new ones, they will be cached again
          #cache action actually uses one central cache, and we would put it everywhere dependencies are install , so if it changes somewhere , everywhere will know-ish
      - name: Install dependencies # we want to cache those dependencies and just use cached ones later
        run: npm ci
      - name: Lint code
        run: npm run lint
      - name: Test code
        run: npm run test
  build:
    needs: test
    runs-on: ubuntu-latest
    outputs: #allow us to define any output of our choice
      script-file: ${{ steps.publish.outputs.script-file  }} #script-file matched the echo 'script-file={}' #this is to access the step context value, need to identify which one, making step output to job level output to be accessed in other jobs #we decide this identifier, will later be used to access the output value
#
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies # we must add step before where files are produced
        uses: actions/cache@v4
        with:
          path: ~/.npm #it's this path that should be cached, npm already builds a cache that contains the dependencies that were installed
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }} #this key will be used to retrieve the cache and recreating that folder on the runner machine, but also if the cache should be discarded because it must be recreated after some dependencies changes
          #hash simply produces a unique hash value based on a file path we pass to it and that hash value will change whenever the file we pass to it changes
          #basically this line says, with the action, this npm created cache folder should be stored in some place in GitHub cloud server and should be reused in other jobs and other workflow executions
          #this cache step does not execute just here but also after the overall job finished to update the cache, so that if dependencies were installed aka new ones, they will be cached again
          #cache action actually uses one central cache, and we would put it everywhere dependencies are install , so if it changes somewhere , everywhere will know-ish
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build
      - name: Publish JS filename                                       #this here is a file managed by github and save the script-file output to the data written from the command
        id: publish
        run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';' #like this doesn't do much , we need to create an output, separate thing from artifact, a simple value
      - name: Upload artifacts
        uses: actions/upload-artifact@v4 #upload artifact action, allows us to get the output
        with:
          name: dist-files #Artifact name
          path: dist #where to find the files to be stored, can specific multiple path, can exclude them as well, pipe symbol for multiple
#            dist
#            package.json #for example
  #files created in one job won't be automatically available in other job since different runner
  deploy:
    needs: build #need to be run after to get artifact
    runs-on: ubuntu-latest
    steps:
      - name: Get build artifacts
        uses: actions/download-artifact@v5 #gets artifact
        with:
          name: dist-files #same name as uploading, grab zip file produced, download it and unzip it
      - name: Output contents
        run: ls
      - name: Output filename
        run: echo "${{ needs.build.outputs.script-file }}" #run command that uses the output by the build job , needs is a context object ??? , when i use needs object, can dive into my job on which this job depends
      - name: Deploy
        run: echo "Deploying..."
